C51 COMPILER V6.12  DS18B20_HCSR04                                                         02/10/2012 09:58:10 PAGE 1   


C51 COMPILER V6.12, COMPILATION OF MODULE DS18B20_HCSR04
OBJECT MODULE PLACED IN .\ds18b20_hcsr04.OBJ
COMPILER INVOKED BY: F:\软件\keil C\C51\BIN\C51.EXE .\ds18b20_hcsr04.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ///无线模块板
   2          #include<reg52.h>
   3          #include<intrins.h>
   4          #define uchar unsigned char
   5          #define uint unsigned int
   6          // hc-sr04  超声波
   7          sbit TRIG=P2^1;
   8          sbit ECHO=P2^2;
   9          //ds18b20  温度传感器
  10          sbit DQ=P2^0;			 
  11          // 1602  液晶
  12          sbit lcdrs=P3^4;
  13          sbit lcdrw=P3^6;
  14          sbit lcden=P3^7;
  15          sbit BELL=P1^6;
  16          uint wendu=0;
  17          uint t1;
  18          bit cuowu;
  19          ////////  1602
  20          void delay1ms(uint z)   //延迟函数
  21          {
  22   1      	uint x,y;
  23   1      	for(x=z;x>0;x--)
  24   1      		for(y=114;y>0;y--);
  25   1      }
  26          
  27          void write_com(uchar com)
  28          {
  29   1      	lcdrs=0;
  30   1      	P0=com;
  31   1      	delay1ms(5);
  32   1      	lcden=1;
  33   1      	delay1ms(5);
  34   1      	lcden=0;
  35   1      }
  36          
  37          void write_data(uchar date)
  38          {
  39   1      	lcdrs=1;
  40   1      	P0=date;
  41   1      	delay1ms(5);
  42   1      	lcden=1;
  43   1      	delay1ms(5);
  44   1      	lcden=0;
  45   1      }
  46          void write_str(uchar *str)  
  47          {  
  48   1       while(*str!='\0')  //未结束   
  49   1       {  
  50   2        write_data(*str++);  
  51   2        delay1ms(1);  
  52   2       }  
  53   1      } 
  54          void init_1602()
  55          {
C51 COMPILER V6.12  DS18B20_HCSR04                                                         02/10/2012 09:58:10 PAGE 2   

  56   1      //	uchar num;
  57   1      //	uchar table[16]={0};
  58   1      //	uchar table1[16]={0}; 
  59   1      	lcdrw=0;
  60   1      	lcden=0;
  61   1      	write_com(0x38);	
  62   1      	write_com(0x0e);
  63   1      	write_com(0x06);
  64   1      	write_com(0x01);
  65   1      	write_com(0x80);
  66   1      /*	for(num=0;num<16;num++)
  67   1      	{
  68   1      		write_data(table[num]);
  69   1      		delay1ms(10);
  70   1      	}
  71   1      	write_com(0x80+0x40);
  72   1      	for(num=0;num<16;num++)
  73   1      	{
  74   1      		write_data(table1[num]);
  75   1      		delay1ms(10);
  76   1      	}
  77   1       */
  78   1      }
  79          /////	 ////			 ds18b20
  80          
  81          bit init_DS18B20()
  82          { 
  83   1      	uchar num;
  84   1      	bit flag;
  85   1      	DQ=1;
  86   1      	for(num=0;num<2;num++);  //先拉高
  87   1      	DQ=0;
  88   1      	for(num=0;num<200;num++);  // 480-960us	powerup
  89   1      	DQ=1;
  90   1      	for(num=0;num<20;num++);	//  >60us   wait
  91   1      	flag=DQ;					// 响应
  92   1      	for(num=0;num<150;num++);	//	 60-240us ds18b20存在信号
  93   1      	DQ=1;
  94   1      	return flag;
  95   1      }
  96          
  97          void DS18B20_WR_CHAR(uchar byte)	// 先写低位
  98          {	
  99   1      	uchar num;
 100   1      	uchar num1;
 101   1      	for(num1=0;num1<8;num1++)
 102   1      	{	 	
 103   2      		DQ=0;		//拉低
 104   2      		_nop_();	//下拉1us
 105   2      		_nop_();
 106   2      		DQ=byte&0x01;
 107   2      		for(num=0;num<20;num++);	//  >60us   wait
 108   2      		byte>>=1;	
 109   2      		DQ=1;	  //拉高	
 110   2      		_nop_();
 111   2      		_nop_();
 112   2      	}		
 113   1      }
 114          
 115          uchar DS18B20_RD_CHAR()	//先读低位
 116          {
 117   1      	uchar num;
C51 COMPILER V6.12  DS18B20_HCSR04                                                         02/10/2012 09:58:10 PAGE 3   

 118   1      	uchar num1;
 119   1      	uchar byte=0;
 120   1      	for(num1=0;num1<8;num1++)
 121   1      	{
 122   2      		DQ=0;  	//拉低
 123   2      		_nop_();
 124   2      		DQ=1;
 125   2      		for(num=0;num<1;num++);  // <10us 	
 126   2      		byte>>=1;
 127   2      		if(DQ==1)
 128   2      			byte|=0x80;
 129   2      		else 
 130   2      			byte|=0x00;
 131   2      		DQ=1;	//拉高
 132   2      		_nop_();
 133   2      		_nop_();
 134   2      		for(num=0;num<20;num++);  //  >60us
 135   2      		
 136   2      	}
 137   1      	return byte;
 138   1      }
 139          
 140          void DS18B20_WENDU()
 141          {
 142   1      	uchar temperaturel=0;
 143   1      	uchar temperatureh=0;
 144   1      	if(init_DS18B20()==0)
 145   1      	{
 146   2      		DS18B20_WR_CHAR(0xcc);
 147   2      		DS18B20_WR_CHAR(0x44);
 148   2      		delay1ms(1000);
 149   2      		if(init_DS18B20()==0)
 150   2      		{	
 151   3      			DS18B20_WR_CHAR(0xcc);
 152   3      			DS18B20_WR_CHAR(0xBE);
 153   3      			_nop_();
 154   3      			temperaturel=DS18B20_RD_CHAR();
 155   3      			temperatureh=DS18B20_RD_CHAR();
 156   3      			wendu=(temperatureh*256+temperaturel)*0.625; //温度比正常大10倍
 157   3      			init_DS18B20();
 158   3      		}			
 159   2      	}
 160   1      }
 161          
 162          ///////
 163          main()
 164          {
 165   1      	unsigned long sj;
 166   1      	uint s;
 167   1      	TRIG=0;
 168   1      	EA=1;
 169   1      	ET1=1;
 170   1      	ET0=1;
 171   1      	TMOD=0x01;
 172   1      	TH0=0;
 173   1      	TL0=0;
 174   1      	s=0;
 175   1      	TR0=0;
 176   1      	wendu=0;
 177   1      	init_1602();
 178   1      	delay1ms(1000);
 179   1      	while(1)
C51 COMPILER V6.12  DS18B20_HCSR04                                                         02/10/2012 09:58:10 PAGE 4   

 180   1      	{
 181   2      		if( init_DS18B20()==0)  	
 182   2           	{   
 183   3      			DS18B20_WENDU();  
 184   3      			write_com(0x80);
 185   3      			write_str("   Tem:");
 186   3      			write_data((wendu/100)%10+48);
 187   3      			write_data((wendu/10)%10+48);
 188   3      			write_data('.');
 189   3      			write_data(wendu%10+48);
 190   3      			write_data(0xdf);
 191   3      			write_data('C');
 192   3      			BELL=0;
 193   3      			delay1ms(1);
 194   3      			BELL=1;
 195   3      		}  
 196   2      		TRIG=1;
 197   2      	 	_nop_();
 198   2      		_nop_();
 199   2      		_nop_();
 200   2      		_nop_();
 201   2      		_nop_();
 202   2      		_nop_();
 203   2      		_nop_();
 204   2      		_nop_();
 205   2      		_nop_();
 206   2      		_nop_();
 207   2      		_nop_();
 208   2      		TRIG=0;
 209   2      		while(!ECHO);
 210   2      		TR0=1;
 211   2      		while(ECHO);
 212   2      		TR0=0;
 213   2      	
 214   2      		sj=TH0*256+TL0;
 215   2      		s=sj*(331.45+61*wendu/10/100)/200/10; 	
 216   2      		 			   
 217   2      		if((s>6000)||(cuowu==1))
 218   2      		{ 	
 219   3      			write_com(0x80+0x40);
 220   3      			write_str("Distance");
 221   3      			write_data(':');
 222   3      			write_data('-');
 223   3      			write_data('.');
 224   3      			write_data('-');
 225   3      			write_data('-');
 226   3      			write_data('-');
 227   3      		}
 228   2      		else
 229   2      		{ 
 230   3      			write_com(0x80+0x40);
 231   3      			write_str("Distance");
 232   3      			write_data(':');
 233   3      			write_data(s/1000%10+48);
 234   3      			write_data('.');
 235   3      		   	write_data(s/100%10+48);
 236   3      		   	write_data(s/10%10+48);
 237   3      			write_data(s%10+48);
 238   3      			write_data('m');
 239   3      		}
 240   2      		TH0=0;
 241   2      	    TL0=0;	
C51 COMPILER V6.12  DS18B20_HCSR04                                                         02/10/2012 09:58:10 PAGE 5   

 242   2      		delay1ms(2000);
 243   2      
 244   2      
 245   2      	}
 246   1      }
 247          
 248          void time0() interrupt 1
 249          {  
 250   1          cuowu=1;  
 251   1      
 252   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    734    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
